{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "a.\tЧто такое решающее дерево? Как по построенному дереву найти прогноз для\n",
    "объекта?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Решающее дерево — решение задачи обучения с учителем, подобное тому, как решает задачи прогнозирования человек. \n",
    "Это бинарное дерево с решающими правилами (или же условиями) в нелистовых вершинах (узлах) и решением (или прогнозом)\n",
    "в листовых вершинах.\n",
    "Для того, чтобы найти прогноз для объекта, нужно: начиная с корня, применить к новому объекту решающее правило. \n",
    "Таким образом определяется, в какой потомок объект должен \"попасть\", и рекурсивно запустить этот процесс для него."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "b.\tЗачем в вершинах нужны предикаты? Какие типы предикатов вы знаете? При-\n",
    "ведите примеры."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Предикаты нужны, чтобы с их помощью можно было дойти от корня дерева до его листьев - решений (прогнозов), \n",
    "тем самым сужая выборку.\n",
    "Пример: [возраст<10]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "c.\tПочему для любой выборки можно построить решающее дерево, имеющее нулевую ошибку на ней?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Потому что можно построить дерево, в каждом листе которого находится ровно по\n",
    "одному объекту выборки. Такое дерево будет являться переобученным и не подойдет для новых данных."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "d.\tПочему не рекомендуется строить небинарные деревья (т.е. имеющие больше\n",
    "двух потомков у каждой вершины)?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Такие деревья будут замедлять поиск."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "e.\tКак устроен жадный алгоритм построения дерева? Какие у него параметры?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Начнем со всей обучающей выборки X и найдем наилучшее ее разбиение на двечасти R1(j, t) = {x | xj < t} \n",
    "и R2(j, t) = {x | xj > t} с точки зрения заранее заданного функционала качества Q(X, j, t). \n",
    "Найдя наилучшие значения j и t, создадим корневую вершину дерева, поставив ей в соответствие \n",
    "предикат [xj < t]. Объекты разобьются на две части — одни попадут в левое поддерево, другие в правое. \n",
    "Для каждой из этих подвыборок рекурсивно повторим процедуру, построив дочерние вершины для корневой, и так далее. \n",
    "В каждой вершине мы проверяем, не выполнилось ли некоторое условие останова — и если выполнилось, \n",
    "то прекращаем рекурсию и объявляем эту вершину листом. Когда дерево построено, каждому листу ставится в\n",
    "соответствие ответ."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "f.\tЗачем нужны критерии информативности?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Они нужны для того, чтобы  можно было выбирать оптимальное разбиение при построении решающего дерева."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "g.\tКак задается критерий ошибки классификации? Критерий Джини? Энтропий-\n",
    "ный критерий? Какой у них смысл?\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Критерий ошибки классификации:\n",
    "Индикатор ошибки рассматривается как функция потерь. Оптимальным предсказанием будет наиболее популярный\n",
    "класс.\n",
    "Критерий Джини:\n",
    "Рассмотрим ситуацию, в которой мы выдаём в вершине не один класс, а распределение на всех классах c = (c1, . . . , cK).\n",
    "Качество такого распределения можно измерять с помощью критерия Бриера.\n",
    "Можно показать, что оптимальный вектор вероятностей состоит из долей классов pk: c∗ = (p1, . . . , pK)\n",
    "Если подставить эти вероятности в исходный критерий информативности и провести\n",
    "ряд преобразований, то получим критерий Джини.\n",
    "Энтропийный критерий:\n",
    "Нужно подставить выражения, полученные при поиске минимума лагранжиана и последующем поиске его дифференциала, в критерий.\n",
    "Получим, что он будет представлять собой энтропию распределения классов.\n",
    "Смысл — погрешность должна быть настолько равномерной, насколько возможно."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
